# 프록시, 프록시 패턴, 데코레이터 패턴

## 프록시
- 클라이언트와 서버의 관계로 설명해보자.
- 클라이언트는 서버에 필요한 것을 요청하고 서버는 클라이언트의 요청을 처리하는 것
- 이 때 클라이언트가 서버를 직접 호출하지 않고 어떤 대리자를 통해서 대신 간접적으로 서버에 요청할 수 있다.
- 여기서 대리자를 영어로 프록시(proxy) 라고 한다.

### 프록시 특징
- 대리자가 중간에서 여러가지 일을 할 수 있다.
- 접근 제어, 캐시, 부가 기능 추가 등..

### 프록시를 만드려면?
- 클라이언트(사용자)가 서버에게 요청한건지, 프록시에게 요청을 한 것인지 몰라야 한다.
- 즉, 서버와 프록시는 같은 인터페이스를 사용
  - 클라이언트는 서버 인터페이스에만 의존해야 한다.
  - DI를 사용해서 가능하다.

### 프록시 주요 기능
- 접근 제어 (권한에 따른 접근 차단, 캐싱, 지연 로딩)
- 부가 기능 추가 (추가 로그를 남긴다, 요청 값, 응답 값을 중간에 변형한다.)
- 두 기능은 다 프록시를 사용하지만, GOF 디자인 패턴에서는 둘의 의도에 따라서 프록시 패턴과 데코레이터 패턴으로 불린다.
  - 프록시 패턴: 접근 제어가 목적
  - 데코레이터 패턴: 새로운 기능 추가가 목적

## 프록시 패턴
- 접근 제어

### 특징
- RealSubject 코드와 클라이언트 코드를 전혀 변경하지 않고 프록시를 도입해서 접근 제어를 했다.
- 클라이언트 코드의 변경 없이 자유롭게 프록시를 넣고 뺄 수 있다.

## 데코레이터 패턴
- 부가 기능

### 특징
- RealComponent 코드와 클라이언트 코드를 전혀 변경하지 않고 부가 기능을 추가했다.
- 데코레이터를 여러개 설정할 수 있다.
- component를 공통적으로 가지고 있고 항상 호출해야 하는 부분이 중복이다.
  - 이 부분은 추상 클래스를 만들어서 컴포넌트와 데코레이터를 명확하게 구분할 수 있을 것 이다.

## 프록시 패턴 vs 데코레이터 패턴
- 데코레이터 패턴에서 추상 클래스를 만들어야 할까?
- 프록시, 데코레이턴 패턴의 모양은 거의 비슷하지 않나?

- 결국 겉모양은 비슷하더라도 만든 의도로 구분된다.
- 프록시 패턴: 다른 개체에 대한 접근 제어
- 데코레이터 패턴: 객체에 추가 책임(기능)을 동적으로 추가
